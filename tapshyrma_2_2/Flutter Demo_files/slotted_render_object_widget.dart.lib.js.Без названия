// Generated by DDC, the Dart Development Compiler (to JavaScript).
// Version: 2.19.2 (stable) (Tue Feb 7 18:37:17 2023 +0000) on "windows_x64"
// Module: packages/flutter/src/widgets/slotted_render_object_widget.dart
// Flags: soundNullSafety(true), enableAsserts(true)
define(['dart_sdk', 'packages/flutter/src/widgets/title.dart', 'packages/flutter/src/rendering/box.dart', 'packages/flutter/src/rendering/layer.dart', 'packages/flutter/src/foundation/debug.dart', 'packages/flutter/src/foundation/key.dart', 'packages/flutter/src/foundation/collections.dart'], (function load__packages__flutter__src__widgets__slotted_render_object_widget_dart(dart_sdk, packages__flutter__src__widgets__title$46dart, packages__flutter__src__rendering__box$46dart, packages__flutter__src__rendering__layer$46dart, packages__flutter__src__foundation__debug$46dart, packages__flutter__src__foundation__key$46dart, packages__flutter__src__foundation__collections$46dart) {
  'use strict';
  const core = dart_sdk.core;
  const _js_helper = dart_sdk._js_helper;
  const _interceptors = dart_sdk._interceptors;
  const collection = dart_sdk.collection;
  const dart = dart_sdk.dart;
  const dartx = dart_sdk.dartx;
  const framework = packages__flutter__src__widgets__title$46dart.src__widgets__framework;
  const box = packages__flutter__src__rendering__box$46dart.src__rendering__box;
  const object = packages__flutter__src__rendering__layer$46dart.src__rendering__object;
  const diagnostics = packages__flutter__src__foundation__debug$46dart.src__foundation__diagnostics;
  const assertions = packages__flutter__src__foundation__debug$46dart.src__foundation__assertions;
  const key = packages__flutter__src__foundation__key$46dart.src__foundation__key;
  const collections = packages__flutter__src__foundation__collections$46dart.src__foundation__collections;
  var slotted_render_object_widget = Object.create(dart.library);
  var $_get = dartx._get;
  var $values = dartx.values;
  var $toString = dartx.toString;
  var $forEach = dartx.forEach;
  var $keys = dartx.keys;
  var $add = dartx.add;
  var $remove = dartx.remove;
  var $_set = dartx._set;
  var $containsValue = dartx.containsValue;
  var $containsKey = dartx.containsKey;
  var $toList = dartx.toList;
  var $runtimeType = dartx.runtimeType;
  var $length = dartx.length;
  var $toSet = dartx.toSet;
  var $putIfAbsent = dartx.putIfAbsent;
  var $contains = dartx.contains;
  var $every = dartx.every;
  var $entries = dartx.entries;
  dart._checkModuleNullSafetyMode(true);
  dart._checkModuleRuntimeTypes(false);
  var T = {
    JSArrayOfDiagnosticsNode: () => (T.JSArrayOfDiagnosticsNode = dart.constFn(_interceptors.JSArray$(diagnostics.DiagnosticsNode)))(),
    LinkedMapOfKey$Element: () => (T.LinkedMapOfKey$Element = dart.constFn(_js_helper.LinkedMap$(key.Key, framework.Element)))(),
    VoidTobool: () => (T.VoidTobool = dart.constFn(dart.fnType(core.bool, [])))(),
    ListOfElement: () => (T.ListOfElement = dart.constFn(core.List$(framework.Element)))(),
    LinkedMapOfKey$ListOfElement: () => (T.LinkedMapOfKey$ListOfElement = dart.constFn(_js_helper.LinkedMap$(key.Key, T.ListOfElement())))(),
    JSArrayOfElement: () => (T.JSArrayOfElement = dart.constFn(_interceptors.JSArray$(framework.Element)))(),
    VoidToListOfElement: () => (T.VoidToListOfElement = dart.constFn(dart.fnType(T.ListOfElement(), [])))()
  };
  const CT = Object.create({
    _: () => (C, CT)
  });
  var I = [
    "package:flutter/src/widgets/slotted_render_object_widget.dart",
    "file:///C:/src/flutter/packages/flutter/lib/src/widgets/slotted_render_object_widget.dart"
  ];
  const _is_SlottedMultiChildRenderObjectWidgetMixin_default = Symbol('_is_SlottedMultiChildRenderObjectWidgetMixin_default');
  slotted_render_object_widget.SlottedMultiChildRenderObjectWidgetMixin$ = dart.generic(S => {
    var __t$SlottedRenderObjectElementOfS = () => (__t$SlottedRenderObjectElementOfS = dart.constFn(slotted_render_object_widget.SlottedRenderObjectElement$(S)))();
    class SlottedMultiChildRenderObjectWidgetMixin extends framework.RenderObjectWidget {}
    SlottedMultiChildRenderObjectWidgetMixin[dart.mixinOn] = RenderObjectWidget => class SlottedMultiChildRenderObjectWidgetMixin extends RenderObjectWidget {
      createElement() {
        return new (__t$SlottedRenderObjectElementOfS()).new(this);
      }
    };
    dart.addTypeTests(SlottedMultiChildRenderObjectWidgetMixin);
    SlottedMultiChildRenderObjectWidgetMixin.prototype[_is_SlottedMultiChildRenderObjectWidgetMixin_default] = true;
    dart.addTypeCaches(SlottedMultiChildRenderObjectWidgetMixin);
    SlottedMultiChildRenderObjectWidgetMixin[dart.implements] = () => [framework.RenderObjectWidget];
    dart.setMethodSignature(SlottedMultiChildRenderObjectWidgetMixin, () => ({
      __proto__: dart.getMethods(SlottedMultiChildRenderObjectWidgetMixin.__proto__),
      createElement: dart.fnType(slotted_render_object_widget.SlottedRenderObjectElement$(S), [])
    }));
    dart.setLibraryUri(SlottedMultiChildRenderObjectWidgetMixin, I[0]);
    return SlottedMultiChildRenderObjectWidgetMixin;
  });
  slotted_render_object_widget.SlottedMultiChildRenderObjectWidgetMixin = slotted_render_object_widget.SlottedMultiChildRenderObjectWidgetMixin$();
  dart.addTypeTests(slotted_render_object_widget.SlottedMultiChildRenderObjectWidgetMixin, _is_SlottedMultiChildRenderObjectWidgetMixin_default);
  var _slotToChild = dart.privateName(slotted_render_object_widget, "_slotToChild");
  var _addDiagnostics = dart.privateName(slotted_render_object_widget, "_addDiagnostics");
  var _setChild = dart.privateName(slotted_render_object_widget, "_setChild");
  var _moveChild = dart.privateName(slotted_render_object_widget, "_moveChild");
  const _is_SlottedContainerRenderObjectMixin_default = Symbol('_is_SlottedContainerRenderObjectMixin_default');
  slotted_render_object_widget.SlottedContainerRenderObjectMixin$ = dart.generic(S => {
    var __t$LinkedMapOfS$RenderBox = () => (__t$LinkedMapOfS$RenderBox = dart.constFn(_js_helper.LinkedMap$(S, box.RenderBox)))();
    var __t$LinkedHashMapOfRenderBox$S = () => (__t$LinkedHashMapOfRenderBox$S = dart.constFn(collection.LinkedHashMap$(box.RenderBox, S)))();
    class SlottedContainerRenderObjectMixin extends box.RenderBox {}
    SlottedContainerRenderObjectMixin[dart.mixinOn] = RenderBox => class SlottedContainerRenderObjectMixin extends RenderBox {
      childForSlot(slot) {
        S.as(slot);
        return this[_slotToChild][$_get](slot);
      }
      get children() {
        return this[_slotToChild][$values];
      }
      debugNameForSlot(slot) {
        S.as(slot);
        if (core.Enum.is(slot)) {
          return core['EnumName|get#name'](slot);
        }
        return dart.toString(slot);
      }
      attach(owner) {
        object.PipelineOwner.as(owner);
        super.attach(owner);
        for (let child of this.children) {
          child.attach(owner);
        }
      }
      detach() {
        super.detach();
        for (let child of this.children) {
          child.detach();
        }
      }
      redepthChildren() {
        this.children[$forEach](dart.bind(this, 'redepthChild'));
      }
      visitChildren(visitor) {
        this.children[$forEach](visitor);
      }
      debugDescribeChildren() {
        let value = T.JSArrayOfDiagnosticsNode().of([]);
        let childToSlot = __t$LinkedHashMapOfRenderBox$S().fromIterables(this[_slotToChild][$values], this[_slotToChild][$keys]);
        for (let child of this.children) {
          this[_addDiagnostics](child, value, this.debugNameForSlot(S.as(childToSlot[$_get](child))));
        }
        return value;
      }
      [_addDiagnostics](child, value, name) {
        value[$add](child.toDiagnosticsNode({name: name}));
      }
      [_setChild](child, slot) {
        S.as(slot);
        let oldChild = this[_slotToChild][$_get](slot);
        if (oldChild != null) {
          this.dropChild(oldChild);
          this[_slotToChild][$remove](slot);
        }
        if (child != null) {
          this[_slotToChild][$_set](slot, child);
          this.adoptChild(child);
        }
      }
      [_moveChild](child, slot, oldSlot) {
        S.as(slot);
        S.as(oldSlot);
        if (!!dart.equals(slot, oldSlot)) dart.assertFailed(null, I[1], 187, 12, "slot != oldSlot");
        let oldChild = this[_slotToChild][$_get](oldSlot);
        if (dart.equals(oldChild, child)) {
          this[_setChild](null, oldSlot);
        }
        this[_setChild](child, slot);
      }
    };
    (SlottedContainerRenderObjectMixin[dart.mixinNew] = function() {
      this[_slotToChild] = new (__t$LinkedMapOfS$RenderBox()).new();
    }).prototype = SlottedContainerRenderObjectMixin.prototype;
    dart.addTypeTests(SlottedContainerRenderObjectMixin);
    SlottedContainerRenderObjectMixin.prototype[_is_SlottedContainerRenderObjectMixin_default] = true;
    dart.addTypeCaches(SlottedContainerRenderObjectMixin);
    SlottedContainerRenderObjectMixin[dart.implements] = () => [box.RenderBox];
    dart.setMethodSignature(SlottedContainerRenderObjectMixin, () => ({
      __proto__: dart.getMethods(SlottedContainerRenderObjectMixin.__proto__),
      childForSlot: dart.fnType(dart.nullable(box.RenderBox), [dart.nullable(core.Object)]),
      debugNameForSlot: dart.fnType(core.String, [dart.nullable(core.Object)]),
      [_addDiagnostics]: dart.fnType(dart.void, [box.RenderBox, core.List$(diagnostics.DiagnosticsNode), core.String]),
      [_setChild]: dart.fnType(dart.void, [dart.nullable(box.RenderBox), dart.nullable(core.Object)]),
      [_moveChild]: dart.fnType(dart.void, [box.RenderBox, dart.nullable(core.Object), dart.nullable(core.Object)])
    }));
    dart.setGetterSignature(SlottedContainerRenderObjectMixin, () => ({
      __proto__: dart.getGetters(SlottedContainerRenderObjectMixin.__proto__),
      children: core.Iterable$(box.RenderBox)
    }));
    dart.setLibraryUri(SlottedContainerRenderObjectMixin, I[0]);
    dart.setFieldSignature(SlottedContainerRenderObjectMixin, () => ({
      __proto__: dart.getFields(SlottedContainerRenderObjectMixin.__proto__),
      [_slotToChild]: dart.finalFieldType(core.Map$(S, box.RenderBox))
    }));
    return SlottedContainerRenderObjectMixin;
  });
  slotted_render_object_widget.SlottedContainerRenderObjectMixin = slotted_render_object_widget.SlottedContainerRenderObjectMixin$();
  dart.addTypeTests(slotted_render_object_widget.SlottedContainerRenderObjectMixin, _is_SlottedContainerRenderObjectMixin_default);
  var _keyedChildren = dart.privateName(slotted_render_object_widget, "_keyedChildren");
  var _debugPreviousSlots = dart.privateName(slotted_render_object_widget, "_debugPreviousSlots");
  var _updateChildren = dart.privateName(slotted_render_object_widget, "_updateChildren");
  var _debugDuplicateKeys = dart.privateName(slotted_render_object_widget, "_debugDuplicateKeys");
  const _is_SlottedRenderObjectElement_default = Symbol('_is_SlottedRenderObjectElement_default');
  slotted_render_object_widget.SlottedRenderObjectElement$ = dart.generic(S => {
    var __t$LinkedMapOfS$Element = () => (__t$LinkedMapOfS$Element = dart.constFn(_js_helper.LinkedMap$(S, framework.Element)))();
    var __t$SlottedContainerRenderObjectMixinOfS = () => (__t$SlottedContainerRenderObjectMixinOfS = dart.constFn(slotted_render_object_widget.SlottedContainerRenderObjectMixin$(S)))();
    var __t$SlottedMultiChildRenderObjectWidgetMixinOfS = () => (__t$SlottedMultiChildRenderObjectWidgetMixinOfS = dart.constFn(slotted_render_object_widget.SlottedMultiChildRenderObjectWidgetMixin$(S)))();
    class SlottedRenderObjectElement extends framework.RenderObjectElement {
      static ['_#new#tearOff'](S, widget) {
        return new (slotted_render_object_widget.SlottedRenderObjectElement$(S)).new(widget);
      }
      get renderObject() {
        return __t$SlottedContainerRenderObjectMixinOfS().as(super.renderObject);
      }
      visitChildren(visitor) {
        this[_slotToChild][$values][$forEach](visitor);
      }
      forgetChild(child) {
        if (!this[_slotToChild][$containsValue](child)) dart.assertFailed(null, I[1], 214, 12, "_slotToChild.containsValue(child)");
        if (!S.is(child.slot)) dart.assertFailed(null, I[1], 215, 12, "child.slot is S");
        if (!this[_slotToChild][$containsKey](child.slot)) dart.assertFailed(null, I[1], 216, 12, "_slotToChild.containsKey(child.slot)");
        this[_slotToChild][$remove](child.slot);
        super.forgetChild(child);
      }
      mount(parent, newSlot) {
        super.mount(parent, newSlot);
        this[_updateChildren]();
      }
      update(newWidget) {
        __t$SlottedMultiChildRenderObjectWidgetMixinOfS().as(newWidget);
        super.update(newWidget);
        if (!this.widget._equals(newWidget)) dart.assertFailed(null, I[1], 230, 12, "widget == newWidget");
        this[_updateChildren]();
      }
      [_updateChildren]() {
        let t0, t0$;
        let slottedMultiChildRenderObjectWidgetMixin = __t$SlottedMultiChildRenderObjectWidgetMixinOfS().as(this.widget);
        if (!dart.fn(() => {
          this[_debugPreviousSlots] == null ? this[_debugPreviousSlots] = slottedMultiChildRenderObjectWidgetMixin.slots[$toList]() : null;
          return collections.listEquals(S, this[_debugPreviousSlots], slottedMultiChildRenderObjectWidgetMixin.slots[$toList]());
        }, T.VoidTobool())()) dart.assertFailed(dart.str(this.widget[$runtimeType]) + ".slots must not change.", I[1], 238, 12, "() {\r\n      _debugPreviousSlots ??= slottedMultiChildRenderObjectWidgetMixin.slots.toList();\r\n      return listEquals(_debugPreviousSlots, slottedMultiChildRenderObjectWidgetMixin.slots.toList());\r\n    }()");
        if (!(slottedMultiChildRenderObjectWidgetMixin.slots[$toSet]()[$length] === slottedMultiChildRenderObjectWidgetMixin.slots[$length])) dart.assertFailed("slots must be unique", I[1], 242, 12, "slottedMultiChildRenderObjectWidgetMixin.slots.toSet().length == slottedMultiChildRenderObjectWidgetMixin.slots.length");
        let oldKeyedElements = this[_keyedChildren];
        this[_keyedChildren] = new (T.LinkedMapOfKey$Element()).new();
        let oldSlotToChild = this[_slotToChild];
        this[_slotToChild] = new (__t$LinkedMapOfS$Element()).new();
        let debugDuplicateKeys = null;
        for (let slot of slottedMultiChildRenderObjectWidgetMixin.slots) {
          let widget = slottedMultiChildRenderObjectWidgetMixin.childForSlot(slot);
          let newWidgetKey = (t0 = widget, t0 == null ? null : t0.key);
          let oldSlotChild = oldSlotToChild[$_get](slot);
          let oldKeyChild = oldKeyedElements[$_get](newWidgetKey);
          let fromElement = null;
          if (oldKeyChild != null) {
            fromElement = oldSlotToChild[$remove](S.as(oldKeyChild.slot));
          } else if ((t0$ = oldSlotChild, t0$ == null ? null : t0$.widget.key) == null) {
            fromElement = oldSlotToChild[$remove](slot);
          } else {
            if (!!dart.equals(dart.nullCheck(oldSlotChild).widget.key, newWidgetKey)) dart.assertFailed(null, I[1], 267, 16, "oldSlotChild!.widget.key != newWidgetKey");
            fromElement = null;
          }
          let newChild = this.updateChild(fromElement, widget, slot);
          if (newChild != null) {
            this[_slotToChild][$_set](slot, newChild);
            if (newWidgetKey != null) {
              if (!dart.fn(() => {
                let t0;
                let existingElement = this[_keyedChildren][$_get](newWidgetKey);
                if (existingElement != null) {
                  (t0 = debugDuplicateKeys, t0 == null ? debugDuplicateKeys = new (T.LinkedMapOfKey$ListOfElement()).new() : t0)[$putIfAbsent](newWidgetKey, dart.fn(() => T.JSArrayOfElement().of([existingElement]), T.VoidToListOfElement()))[$add](newChild);
                }
                return true;
              }, T.VoidTobool())()) dart.assertFailed(null, I[1], 276, 18, "() {\r\n            final Element? existingElement = _keyedChildren[newWidgetKey];\r\n            if (existingElement != null) {\r\n              (debugDuplicateKeys ??= <Key, List<Element>>{})\r\n                .putIfAbsent(newWidgetKey, () => <Element>[existingElement])\r\n                .add(newChild);\r\n            }\r\n            return true;\r\n          }()");
              this[_keyedChildren][$_set](newWidgetKey, newChild);
            }
          }
        }
        oldSlotToChild[$values][$forEach](dart.bind(this, 'deactivateChild'));
        if (!this[_debugDuplicateKeys](debugDuplicateKeys)) dart.assertFailed(null, I[1], 290, 12, "_debugDuplicateKeys(debugDuplicateKeys)");
        if (!this[_keyedChildren][$values][$every](dart.bind(this[_slotToChild][$values], $contains))) dart.assertFailed("_keyedChildren " + dart.str(this[_keyedChildren][$values]) + " should be a subset of " + dart.str(this[_slotToChild][$values]), I[1], 291, 12, "_keyedChildren.values.every(_slotToChild.values.contains)");
      }
      [_debugDuplicateKeys](debugDuplicateKeys) {
        if (debugDuplicateKeys == null) {
          return true;
        }
        for (let duplicateKey of debugDuplicateKeys[$entries]) {
          dart.throw(new assertions.FlutterError.fromParts((() => {
            let t0 = T.JSArrayOfDiagnosticsNode().of([new assertions.ErrorSummary.new("Multiple widgets used the same key in " + dart.str(this.widget[$runtimeType]) + "."), new assertions.ErrorDescription.new("The key " + dart.str(duplicateKey.key) + " was used by multiple widgets. The offending widgets were:\n")]);
            for (let element of duplicateKey.value)
              t0.push(new assertions.ErrorDescription.new("  - " + dart.str(element) + "\n"));
            t0.push(new assertions.ErrorDescription.new("A key can only be specified on one widget at a time in the same parent widget."));
            return t0;
          })()));
        }
        return true;
      }
      insertRenderObjectChild(child, slot) {
        box.RenderBox.as(child);
        S.as(slot);
        this.renderObject[_setChild](child, slot);
        if (!dart.equals(this.renderObject[_slotToChild][$_get](slot), child)) dart.assertFailed(null, I[1], 316, 12, "renderObject._slotToChild[slot] == child");
      }
      removeRenderObjectChild(child, slot) {
        box.RenderBox.as(child);
        S.as(slot);
        if (dart.equals(this.renderObject[_slotToChild][$_get](slot), child)) {
          this.renderObject[_setChild](null, slot);
          if (!(this.renderObject[_slotToChild][$_get](slot) == null)) dart.assertFailed(null, I[1], 323, 14, "renderObject._slotToChild[slot] == null");
        }
      }
      moveRenderObjectChild(child, oldSlot, newSlot) {
        box.RenderBox.as(child);
        S.as(oldSlot);
        S.as(newSlot);
        this.renderObject[_moveChild](child, newSlot, oldSlot);
      }
    }
    (SlottedRenderObjectElement.new = function(widget) {
      this[_slotToChild] = new (__t$LinkedMapOfS$Element()).new();
      this[_keyedChildren] = new (T.LinkedMapOfKey$Element()).new();
      this[_debugPreviousSlots] = null;
      SlottedRenderObjectElement.__proto__.new.call(this, widget);
      ;
    }).prototype = SlottedRenderObjectElement.prototype;
    dart.addTypeTests(SlottedRenderObjectElement);
    SlottedRenderObjectElement.prototype[_is_SlottedRenderObjectElement_default] = true;
    dart.addTypeCaches(SlottedRenderObjectElement);
    dart.setMethodSignature(SlottedRenderObjectElement, () => ({
      __proto__: dart.getMethods(SlottedRenderObjectElement.__proto__),
      [_updateChildren]: dart.fnType(dart.void, []),
      [_debugDuplicateKeys]: dart.fnType(core.bool, [dart.nullable(core.Map$(key.Key, core.List$(framework.Element)))])
    }));
    dart.setGetterSignature(SlottedRenderObjectElement, () => ({
      __proto__: dart.getGetters(SlottedRenderObjectElement.__proto__),
      renderObject: slotted_render_object_widget.SlottedContainerRenderObjectMixin$(S)
    }));
    dart.setLibraryUri(SlottedRenderObjectElement, I[0]);
    dart.setFieldSignature(SlottedRenderObjectElement, () => ({
      __proto__: dart.getFields(SlottedRenderObjectElement.__proto__),
      [_slotToChild]: dart.fieldType(core.Map$(S, framework.Element)),
      [_keyedChildren]: dart.fieldType(core.Map$(key.Key, framework.Element)),
      [_debugPreviousSlots]: dart.fieldType(dart.nullable(core.List$(S)))
    }));
    return SlottedRenderObjectElement;
  });
  slotted_render_object_widget.SlottedRenderObjectElement = slotted_render_object_widget.SlottedRenderObjectElement$();
  dart.addTypeTests(slotted_render_object_widget.SlottedRenderObjectElement, _is_SlottedRenderObjectElement_default);
  dart.trackLibraries("packages/flutter/src/widgets/slotted_render_object_widget.dart", {
    "package:flutter/src/widgets/slotted_render_object_widget.dart": slotted_render_object_widget
  }, {
  }, '{"version":3,"sourceRoot":"","sources":["slotted_render_object_widget.dart"],"names":[],"mappings":"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","file":"../../../../../../../packages/flutter/src/widgets/slotted_render_object_widget.dart.lib.js"}');
  // Exports:
  return {
    src__widgets__slotted_render_object_widget: slotted_render_object_widget
  };
}));

//# sourceMappingURL=slotted_render_object_widget.dart.lib.js.map
